#include <srpc/core.hpp>
#include <srpc/transport.hpp>
#include <srpc/packer.hpp>
#include <stdexcept>
#include <cstdint>

/**
 * This is an auto-generated file generated by srpc. Do not modify!
 */

struct Number : public srpc::message_base {
	int32_t num;

	// overrides
	static constexpr const char* name = "Number";
	static constexpr auto fields = std::make_tuple(
		STRUCT_MEMBER(Number, num, "Number::num")
	);
	void unpack(srpc::buffer::ptr bp) override {
		srpc::packer p(bp);
		p >> num;
	}
};

struct TwoNumbers : public srpc::message_base {
	int32_t left;
	int32_t right;

	// overrides
	static constexpr const char* name = "TwoNumbers";
	static constexpr auto fields = std::make_tuple(
		STRUCT_MEMBER(TwoNumbers, left, "TwoNumbers::left"),
		STRUCT_MEMBER(TwoNumbers, right, "TwoNumbers::right")
	);
	void unpack(srpc::buffer::ptr bp) override {
		srpc::packer p(bp);
		p >> left;
		p >> right;
	}
};

struct Calculator_stub {
	Calculator_stub() {
		if (!_init) {
			srpc::message_registry["TwoNumbers"] = []() -> std::unique_ptr<TwoNumbers> {
				return std::make_unique<TwoNumbers>();
			};
			srpc::message_registry["Number"] = []() -> std::unique_ptr<Number> {
				return std::make_unique<Number>();
			};
		}
		_init = true;
	}

	void register_insecure_channel(std::string server_ip, std::string port) {
		if (_socket != -1) { close(_socket); }
		_socket = srpc::transport::create_client_socket(server_ip, port);
	}

	Number add(TwoNumbers& req) {
		srpc::packer pr;
		srpc::request_t<TwoNumbers> request;
		request.set_method_name("Calculator_servicer::add");
		request.set_value(std::move(req));
		pr.pack_request(request);

		srpc::transport::send_data(_socket, (*pr.buf()).data(), pr.size());
		srpc::message_t res = srpc::transport::recv_data(_socket);
		srpc::packer rpr(res.data(), res.size());

		srpc::response_t<Number> msg = rpr.unpack_response<Number>();

		return msg.value();
	}
	Number subtract(TwoNumbers& req) {
		srpc::packer pr;
		srpc::request_t<TwoNumbers> request;
		request.set_method_name("Calculator_servicer::subtract");
		request.set_value(std::move(req));
		pr.pack_request(request);

		srpc::transport::send_data(_socket, (*pr.buf()).data(), pr.size());
		srpc::message_t res = srpc::transport::recv_data(_socket);
		srpc::packer rpr(res.data(), res.size());

		srpc::response_t<Number> msg = rpr.unpack_response<Number>();

		return msg.value();
	}
	Number multiply(TwoNumbers& req) {
		srpc::packer pr;
		srpc::request_t<TwoNumbers> request;
		request.set_method_name("Calculator_servicer::multiply");
		request.set_value(std::move(req));
		pr.pack_request(request);

		srpc::transport::send_data(_socket, (*pr.buf()).data(), pr.size());
		srpc::message_t res = srpc::transport::recv_data(_socket);
		srpc::packer rpr(res.data(), res.size());

		srpc::response_t<Number> msg = rpr.unpack_response<Number>();

		return msg.value();
	}
	Number divide(TwoNumbers& req) {
		srpc::packer pr;
		srpc::request_t<TwoNumbers> request;
		request.set_method_name("Calculator_servicer::divide");
		request.set_value(std::move(req));
		pr.pack_request(request);

		srpc::transport::send_data(_socket, (*pr.buf()).data(), pr.size());
		srpc::message_t res = srpc::transport::recv_data(_socket);
		srpc::packer rpr(res.data(), res.size());

		srpc::response_t<Number> msg = rpr.unpack_response<Number>();

		return msg.value();
	}
	Number square(Number& req) {
		srpc::packer pr;
		srpc::request_t<Number> request;
		request.set_method_name("Calculator_servicer::square");
		request.set_value(std::move(req));
		pr.pack_request(request);

		srpc::transport::send_data(_socket, (*pr.buf()).data(), pr.size());
		srpc::message_t res = srpc::transport::recv_data(_socket);
		srpc::packer rpr(res.data(), res.size());

		srpc::response_t<Number> msg = rpr.unpack_response<Number>();

		return msg.value();
	}
private:
	static bool _init;
	int32_t _socket = -1;
};

inline bool Calculator_stub::_init = false;

struct Calculator_servicer : srpc::servicer_base {
	virtual Number add(TwoNumbers& req) { throw std::runtime_error("Method not implemented!"); }
	virtual Number subtract(TwoNumbers& req) { throw std::runtime_error("Method not implemented!"); }
	virtual Number multiply(TwoNumbers& req) { throw std::runtime_error("Method not implemented!"); }
	virtual Number divide(TwoNumbers& req) { throw std::runtime_error("Method not implemented!"); }
	virtual Number square(Number& req) { throw std::runtime_error("Method not implemented!"); }

	static constexpr const char* name = "Calculator";
	static constexpr auto methods = std::make_tuple(
		STRUCT_MEMBER(Calculator_servicer, add, "Calculator_servicer::add"),
		STRUCT_MEMBER(Calculator_servicer, subtract, "Calculator_servicer::subtract"),
		STRUCT_MEMBER(Calculator_servicer, multiply, "Calculator_servicer::multiply"),
		STRUCT_MEMBER(Calculator_servicer, divide, "Calculator_servicer::divide"),
		STRUCT_MEMBER(Calculator_servicer, square, "Calculator_servicer::square")
	);
};

